# Building RAPs with R - Part 2.10
Erika Duan
2025-06-11

- [Recording package versions with
  `renv`](#recording-package-versions-with-renv)
- [What daily `renv` usage looks
  like](#what-daily-renv-usage-looks-like)
- [What we need for full project
  reproducibility](#what-we-need-for-full-project-reproducibility)
- [Other hacks](#other-hacks)

# Recording package versions with `renv`

The principle behind `renv` is very simple:

- Install the required R package.  
- Obtain a snapshot of the R version, all R packages used and their
  versions in the `renv.lock` file. This JSON file should be saved at
  the root of your project and an example can be found
  [here](https://github.com/erikaduan/abs_labour_force_report/blob/main/renv.lock).  
- This snapshot can then be used to restore the project library in the
  future without interfering with other packages installed on your local
  machine.

**Note:** the last feature occurs as `renv` creates a new R library for
each project, which means that you can install multiple versions of a
package i.e.Â `dplyr` on your local machine and `renv` tracks the
specific `dplyr` version required for each project.

``` r
# Record package versions with renv --------------------------------------------
# renv functions should be executed directly in the R console

renv::init()
# Searches for R package dependencies
# Copies packages into the cache
# Creates the lockfile
```

In each project root directory, running `renv::init()` creates:

- A project-specific subdirectory named `renv`.  
- A project-specific `.Rprofile` file which contains the line
  `source("renv/activate.R")`.

**Note:** The `renv` subdirectory contains the subdirectory `library`,
which contains our isolated project-specific library of R packages. The
`library` subdirectory therefore should never be committed by Git and a
`.gitignore` file is automatically generated by `renv::init()` inside
`./renv` to manage this.

``` r
# Restore package versions with renv -------------------------------------------
# Another user clones the remote code repository   

renv::restore() 
# Type Y to activate the project before restoring the renv lockfile
# Type Y again to install required R packages for the project
```

The operation `renv::restore()` can fail in one machine but succeed in
another. This is because different machines may also have different
operating system tools that `renv` fails to account for. This includes:

- The R version of your machine  
- C/C++ package dependencies for R package compilation like
  [`Rtools`](https://cran.r-project.org/bin/windows/Rtools/)

Although `renv` requires users to manually reproduce the original
operating system for guaranteed reproducibility, it is still useful for:

- Managing package requirements and dependencies at the project level.  
- Moving away from using a single system-wide library for multiple
  projects (bad practice).  
- Providing an R and R package installation blueprint for Docker via
  `renv.lock`.

# What daily `renv` usage looks like

1.  Create a new R project in an empty directory and add your code via
    scripts or notebooks.  
2.  Load packages for your project using `library("package)` syntax.  
3.  Run `renv::init()` and activate `renv` to set up your
    project-specific R library.  
4.  If your project requires the installation of a new package, start an
    R session within your project and run
    `install.packages("new_package")`. You can also use
    `renv::install("new_package_version")` to install a specific version
    of an R package for your project.  
5.  Update your `renv.lock` file to reflect your new project package
    dependencies using `renv::snapshot()`.  
6.  To upgrade the version of an existing R package, run
    `update.packages()` within your project R session and then update
    the R package version using `renv::snapshot()`.  
7.  Upon project completion, update your `renv.lock` file again using
    `renv::snapshot()`.  
8.  Commit your project-specific `renv.lock` file using Git.

**Note:** Updating an R package version during your project may break
your code or introduce unexpected side-effects, which is why unit
testing is important.

# What we need for full project reproducibility

| Requirement | Tools required |
|:---|:---|
| Reproduce the original R version | Docker or `conda` |
| Reproduce other operating system tools required for R package compilation | Docker or `conda` |
| Install project-specific R package dependencies | `renv` |
| Install project-specific Python package dependencies if our workflow uses Python via `reticulate` | `uv` via `reticulate` |

# Other hacks

In the absence of a `renv.lock` file, you can use `groundhog` or `rang`
to download the R package versions that existed at a certain date in
time.

``` r
# Install the most recent R package version available at a specific date -------
packages <- c("dplyr", "ggplot2")   
groundhog::groundhog.library(pkgs, "2021-09-01")   
```

**Note:** `groundhog` also provides a warning about the last R version
available for your specified date.
